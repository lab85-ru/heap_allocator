#include <stdint.h>
#include <string.h>
#include "printf_hal.h"
#include "ma.h"
#include "ma_cfg.h"

// Алокатор работает с двумя массивами,
//
// ПЕРВЫЙ массив - это массив typedef struct ma_mcb_t, это двух связный список 
// описывающий количество страниц в текущей записи - занятых или свободных.
// 
// Размер массива = количеству страниц памяти выделенных под кучу !
// т.е. на каждую страницу памяти(кучи) выделяется 1 запись !
//
// первый элемент ссылается сам на себя (на запись 0), 
// последний элемент ссылается на начало (на запись 0)
//
//
// ВТОРОЙ массив - это массим самой кучи, из которой будет выделяться 
// память приложениям, память выделяется размером кратным СТРАНИЦАМ (MA_PAGE_SIZE).
//
// Оба массива изолированны друг от друга, в случаии переполнения памяти 
// (во втором массиве) при пересечении участков памяти на происходи разрущение 
// двух связного списка (в отличии от версии с вовместным расположением).
//
// размер typedef struct ma_mcb_t должен укладываться в степень 2 т.к. 
// это будет оптимально для применения с кешом размером 64 байта
//
//
// Ограничения:
// размер ma_mcb_t = 8 байт (кратность степени 2, оптимально для кеша размером 64 байта)
// размер prev_mcb и next_mcb = по 2 байта, каждый.
// Таким образом максимальное колличество записей может быть 65536 шт
//
// Объем памяти с которой может работать аллокатор составляет:
// 65536 * размер страници (MA_PAGE_SIZE = 4к) = 256 Мгб
//
// Если необходимо больше то: 
// 1 - Или увеличить размер СТРАНИЦИ
// 2 - Или увеличить размер элементов prev_mcb и next_mcb
//


//=============================================================================
// Таблица(список) блоков управления
//=============================================================================
static ma_mcb_t ma_mcb[ MA_PAGE_NUMBER ];

//=============================================================================
// сама куча
//=============================================================================
static uint8_t ma_heap[ MA_PAGE_SIZE * MA_PAGE_NUMBER ];

//=============================================================================
// Начальная инициализация памяти
//
// Первая запись(prev_mcb) ссылается на себя (на запись 0)
// Последняя запись (next_mcb) ссылается на начало (на запись 0)
//
//=============================================================================
void ma_init( void )
{
    memset(ma_mcb, 0, sizeof(ma_mcb) * MA_PAGE_NUMBER);

    ma_mcb[0].prev_mcb = 0;
	ma_mcb[0].next_mcb = 0;
	ma_mcb[0].ts.size  = MA_PAGE_NUMBER;
	ma_mcb[0].ts.mark  = MA_MARK_FREE;
}

//=============================================================================
// Выделение памяти размером size в куче.
//
// Результат:
// Удачно: возвращает адрес начала выделенной памяти
// Не удачно: возвращает NULL
//=============================================================================
void * ma_malloc( size_t size )
{
	size_t pages      = 0; // количество страниц которое нужно выделить для размещения size
	size_t pages_free = 0; // количество страниц свободных в записи (перед тем как его изменять)
	uint16_t i        = 0; // индекс номер текущей записи
	uint16_t cur_next = 0; // сюда сохраняем текущее значение .next_mcb

	if (size == 0) return 0;

	// расчет сколько страниц нужно выделить
    pages = (size / MA_PAGE_SIZE);
	if ( size % MA_PAGE_SIZE ) pages++;

	i = 0; // начальный индекс с которого начинаем поиск

	while(i != MA_PAGE_NUMBER || i != ma_mcb[ i ].next_mcb){
	    if (ma_mcb[ i ].ts.mark == MA_MARK_BUSY){           // эта запись помечена как занятая,
            i = ma_mcb[ i ].next_mcb;                       // переходим на следующею запись
		    continue;
	    }

	    pages_free = ma_mcb[ i ].ts.size;                   // размер свободного места (перед тем как его изменять)
		cur_next   = ma_mcb[ i ].next_mcb;                  // сохранили значение ссылки на сл.запись

		if ( pages_free < pages){                           // нет места для размешения pages страниц,
			 i = ma_mcb[ i ].next_mcb;                      // переходим на следующею запись
			 continue;
		}

		ma_mcb[ i ].ts.mark  = MA_MARK_BUSY;            // пометили занята
		ma_mcb[ i ].ts.size  = pages;                   // задали новый размер

		if ( pages_free > pages){                       // разделяем одну запись на две (1-занята(тек.), 2-свободна(след.))
			ma_mcb[ i + pages ].ts.mark  = MA_MARK_FREE;
			ma_mcb[ i + pages ].ts.size  = pages_free - pages;
		    ma_mcb[ i + pages ].prev_mcb = i;           // сл.запись ссылка на предыдущею
            ma_mcb[ i + pages ].next_mcb = cur_next;    // сл.запись ссылка на запись за ней

  	    	ma_mcb[ i ].next_mcb = i + pages;           // задали ссылку на сл запись
		}else{// pages_free == pages
			ma_mcb[ i ].next_mcb = cur_next;            // задали ссылку на сл запись
	    }
        return &ma_heap[ i * MA_PAGE_SIZE ];
	} // while

	return 0;
}


void ma_union_record( uint16_t i1 )
{
    uint16_t n2, j3;

    n2 = ma_mcb[ i1 ].next_mcb;                           // номер следующей записи, с ней объединяем
    j3 = ma_mcb[ n2 ].next_mcb;                           // номер следующей записи, в ней нужно будет изменить ссылку
    ma_mcb[ i1 ].ts.size  = ma_mcb[ i1 ].ts.size + ma_mcb[ n2 ].ts.size; // новый размер сумма двух разделов
	ma_mcb[ i1 ].next_mcb = ma_mcb[ n2 ].next_mcb;
	ma_mcb[ j3 ].prev_mcb = i1;                           // заменили ссылку, третья запись теперь ссылается на i1
}


//=============================================================================
// освобождение памяти
// помечает в таблице блоков управления + склеивает с рядом стоящими записями
// если они помечены как свободные
//=============================================================================
void ma_free( void *ptr )
{
	void *p_begin = (void *)&ma_heap[0];
	void *p_end   = (void *)&ma_heap[ MA_PAGE_SIZE * MA_PAGE_NUMBER ];

	uint16_t n;
	uint16_t i;

	if (ptr == 0) return;
	if (ptr < p_begin || ptr > p_end) return; // Ошибка, освобождаемая память не входит в массив

	// номер записи по входному адресу
	if (ptr == ma_heap) 
		n = 0;
	else
		n = (uint16_t)((uint32_t)ptr - (uint32_t)((void *)ma_heap)) / MA_PAGE_SIZE;

	ma_mcb[ n ].ts.mark = MA_MARK_FREE;  // пометили что свободна

	// просмотр следующая(нижняя) запись свободна ?
	if (ma_mcb[ n ].next_mcb != 0){
		i = ma_mcb[ n ].next_mcb;
		if (ma_mcb[ i ].ts.mark == MA_MARK_FREE ) ma_union_record( n );
	}

	// просмотр предыдущая(верхняя) запись свободна ?
	if (n != 0){
		i = ma_mcb[ n ].prev_mcb;
		if( ma_mcb[ i ].ts.mark == MA_MARK_FREE ) ma_union_record( i );
	}
	return ;
}

//=============================================================================
// распечатка карты памяти
//=============================================================================
void ma_view( void )
{
    uint16_t i = 0;

	printf("=================================================================\r\n");
	while(1){
		printf("RECORD %u : ", i);
		if (ma_mcb[ i ].ts.mark == MA_MARK_FREE) printf("=FREE= ");else printf(" Busy  ");
		printf("prev[ %d ], next[ %d ], size[ %d ]  ", \
			   ma_mcb[ i ].prev_mcb, ma_mcb[ i ].next_mcb, ma_mcb[ i ].ts.size);
		printf("address: 0x%08x\r\n", &ma_heap[ i * MA_PAGE_SIZE ]);
        if (ma_mcb[ i ].next_mcb) i = ma_mcb[ i ].next_mcb; else return;
	}
	printf("=================================================================\r\n");
}

